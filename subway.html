<!DOCTYPE html>

<html lang="en">

<head>

   <meta charset="UTF-8">

   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

   <title>Subway: Fatal Impact</title>

   <style>

       @import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');

      

       body { margin: 0; overflow: hidden; background: #2c3e50; font-family: 'Titan One', sans-serif; user-select: none; }

      

       #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }


       .hud-top { display: flex; justify-content: space-between; padding: 25px; }

       .score-val { font-size: 50px; color: #fff; -webkit-text-stroke: 2px #000; text-shadow: 4px 4px 0 rgba(0,0,0,0.5); }

       .coin-box { background: rgba(0,0,0,0.6); border: 3px solid #fff; border-radius: 30px; padding: 10px 25px; display: flex; align-items: center; gap: 15px; }

       .coin-val { font-size: 30px; color: #fff; }


       #start-screen {

           position: absolute; top: 0; left: 0; width: 100%; height: 100%;

           background: radial-gradient(circle, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.95) 100%);

           display: flex; flex-direction: column; align-items: center; justify-content: center;

           pointer-events: auto; z-index: 10; transition: opacity 0.3s;

       }

       .hidden { opacity: 0; pointer-events: none; }

      

       .logo { font-size: 90px; color: #fff; -webkit-text-stroke: 3px #000; text-shadow: 0 10px 0 #2980b9; transform: skewY(-5deg); margin-bottom: 40px; text-align: center; }

      

       button {

           background: linear-gradient(#2ecc71, #27ae60); border: none; padding: 25px 80px;

           font-size: 35px; color: white; border-radius: 60px; font-family: inherit; cursor: pointer;

           box-shadow: 0 10px 0 #1e8449; transition: transform 0.1s;

       }

       button:active { transform: translateY(6px); box-shadow: 0 4px 0 #1e8449; }


       #game-over {

           position: absolute; top: 0; left: 0; width: 100%; height: 100%;

           background: rgba(192, 57, 43, 0.95); display: none; flex-direction: column;

           align-items: center; justify-content: center; pointer-events: auto; z-index: 20;

       }


       #flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 30; }

   </style>

   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

</head>

<body>


   <div id="ui">

       <div class="hud-top">

           <div class="score-val" id="score">0</div>

           <div class="coin-box"><span style="color:#f1c40f;font-size:30px">$</span><div class="coin-val" id="coins">0</div></div>

       </div>

   </div>


   <div id="start-screen">

       <div class="logo">SUBWAY<br>REALISM</div>

       <button onclick="Game.start()">TAP TO RUN</button>

   </div>


   <div id="game-over">

       <h1 style="color:white; font-size:80px; -webkit-text-stroke:3px black; margin-bottom:10px;">CRASHED!</h1>

       <h2 style="color:#f1c40f; font-size:40px;">Score: <span id="final-score">0</span></h2>

       <button onclick="location.reload()">TRY AGAIN</button>

   </div>


   <div id="flash"></div>


   <script>

       // --- 1. ASSET GENERATOR (High Res) ---

       const Assets = {

           tex(w, h, fn) {

               const c = document.createElement('canvas'); c.width=w; c.height=h;

               fn(c.getContext('2d'), w, h);

               const t = new THREE.CanvasTexture(c);

               t.wrapS = t.wrapT = THREE.RepeatWrapping;

               return t;

           },

           init() {

               // Ground: Detailed Gravel

               this.ground = this.tex(1024, 1024, (c, w, h) => {

                   c.fillStyle = '#4e342e'; c.fillRect(0,0,w,h);

                   for(let i=0; i<20000; i++) {

                       c.fillStyle = Math.random()>0.5 ? '#3e2723' : '#5d4037';

                       c.fillRect(Math.random()*w, Math.random()*h, 3, 3);

                   }

               });

               // Train Metal

               this.metal = this.tex(512, 512, (c, w, h) => {

                   c.fillStyle = '#bdc3c7'; c.fillRect(0,0,w,h);

                   // Grunge

                   for(let i=0; i<1000; i++) {

                       c.fillStyle = 'rgba(0,0,0,0.05)';

                       c.fillRect(Math.random()*w, Math.random()*h, 50, 50);

                   }

                   c.fillStyle = '#2c3e50'; c.fillRect(0, h-40, w, 40); // Base trim

               });

               // Red Paint

               this.red = this.tex(512, 512, (c, w, h) => {

                   c.fillStyle = '#c0392b'; c.fillRect(0,0,w,h);

                   c.fillStyle = '#922b21';

                   for(let i=0; i<w; i+=40) c.fillRect(i, 0, 4, h); // Corrugated lines

                   // Graffiti

                   c.save(); c.translate(w/2, h/2); c.rotate(-0.2);

                   c.font = 'bold 80px Arial'; c.fillStyle = '#f1c40f'; c.strokeStyle='black'; c.lineWidth=4;

                   c.textAlign='center'; c.strokeText("SUBWAY", 0,0); c.fillText("SUBWAY", 0,0);

                   c.restore();

               });

               // Brick

               this.brick = this.tex(512, 512, (c, w, h) => {

                   c.fillStyle = '#34495e'; c.fillRect(0,0,w,h);

                   c.fillStyle = '#2c3e50';

                   for(let y=0; y<h; y+=40) {

                       for(let x=0; x<w; x+=80) {

                           const o = (y/40)%2===0 ? 0 : 40;

                           c.fillRect(x+o, y, 75, 35);

                       }

                   }

               });

               // Particle

               this.part = this.tex(64,64,(c,w,h)=>{

                   c.fillStyle='#f1c40f'; c.beginPath(); c.arc(32,32,30,0,Math.PI*2); c.fill();

               });

           }

       };


       // --- 2. CURVED WORLD SHADER ---

       const Curver = {

           inject(s) {

               s.uniforms.uC = {value: 0.0008};

               s.vertexShader = `uniform float uC;\n` + s.vertexShader.replace('#include <begin_vertex>',`

                   #include <begin_vertex>

                   float z = (modelMatrix * vec4(position, 1.0)).z;

                   float dist = min(0.0, z + 5.0);

                   transformed.y += (dist * dist) * -uC;

               `);

           }

       };


       // --- 3. CONFIG ---

       const CFG = { GRAVITY: 0.16, JUMP: 1.35, SPEED: 0.45, LANES: [-3.5, 0, 3.5] };


       // --- 4. GAME ENGINE ---

       const Game = {

           scene:null, cam:null, ren:null, world:null,

           active:false, speed:CFG.SPEED, score:0, coins:0, particles:[],

          

           init() {

               Assets.init();

               this.scene = new THREE.Scene();

               this.scene.background = new THREE.Color(0x3498db);

               this.scene.fog = new THREE.Fog(0x3498db, 30, 90);


               this.cam = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);

               this.cam.position.set(0, 5.5, 9);

               this.cam.lookAt(0, 0, -6);


               this.ren = new THREE.WebGLRenderer({antialias:true});

               this.ren.setSize(innerWidth, innerHeight);

               this.ren.shadowMap.enabled = true;

               document.body.appendChild(this.ren.domElement);


               // Lighting

               const amb = new THREE.AmbientLight(0xffffff, 0.6);

               this.scene.add(amb);

               const dir = new THREE.DirectionalLight(0xffffff, 0.9);

               dir.position.set(20, 50, 20);

               dir.castShadow = true;

               dir.shadow.mapSize.set(2048, 2048);

               this.scene.add(dir);


               this.world = new THREE.Group();

               this.scene.add(this.world);


               Player.init();

               Level.init();


               // Input

               const hInput = (dx, dy) => {

                   if(!this.active) return;

                   if(Math.abs(dx) > Math.abs(dy)) {

                       if(Math.abs(dx)>30) Player.move(dx>0?1:-1);

                   } else {

                       if(Math.abs(dy)>30) dy>0 ? Player.roll() : Player.jump();

                   }

               };

               let sx=0, sy=0;

               window.onkeydown=e=>{

                   if(!this.active) return;

                   if(e.key=='ArrowLeft'||e.key=='a') Player.move(-1);

                   if(e.key=='ArrowRight'||e.key=='d') Player.move(1);

                   if(e.key=='ArrowUp'||e.key=='w') Player.jump();

                   if(e.key=='ArrowDown'||e.key=='s') Player.roll();

               };

               window.ontouchstart=e=>{sx=e.touches[0].clientX; sy=e.touches[0].clientY;};

               window.ontouchend=e=>hInput(e.changedTouches[0].clientX-sx, e.changedTouches[0].clientY-sy);

               window.onmousedown=e=>{sx=e.clientX; sy=e.clientY;};

               window.onmouseup=e=>hInput(e.clientX-sx, e.clientY-sy);

               window.onresize=()=>{this.cam.aspect=innerWidth/innerHeight; this.cam.updateProjectionMatrix(); this.ren.setSize(innerWidth,innerHeight);};


               this.loop();

           },


           start() {

               document.getElementById('start-screen').classList.add('hidden');

               document.getElementById('game-over').style.display='none';

               this.active = true;

               this.speed = CFG.SPEED;

               this.score = 0; this.coins = 0;

               this.world.position.z = 0;

               Level.reset();

               Player.reset();

           },


           gameOver() {

               this.active = false;

               document.getElementById('flash').style.opacity = 0.8;

               setTimeout(()=>document.getElementById('flash').style.opacity=0, 150);

               document.getElementById('final-score').innerText = Math.floor(this.score);

               document.getElementById('game-over').style.display = 'flex';

           },


           spawnP(x,y,z) {

               const m = new THREE.MeshBasicMaterial({map:Assets.part, color:0xffd700, transparent:true});

               const p = new THREE.Mesh(new THREE.PlaneGeometry(0.5,0.5), m);

               p.pos=new THREE.Vector3(x,y,z); p.position.copy(p.pos);

               p.vel=new THREE.Vector3((Math.random()-.5)*0.2, Math.random()*0.2, (Math.random()-.5)*0.2);

               p.life=1.0; p.lookAt(this.cam.position);

               this.scene.add(p); this.particles.push(p);

           },


           loop() {

               requestAnimationFrame(this.loop.bind(this));

              

               if(this.active) {

                   this.speed = Math.min(this.speed+0.0002, 1.6);

                   const dt = this.speed;

                   this.world.position.z += dt;

                   this.score += dt * 5;

                  

                   Player.update();

                   Level.update(this.world.position.z);

                  

                   document.getElementById('score').innerText = Math.floor(this.score).toString().padStart(6,'0');

                   document.getElementById('coins').innerText = this.coins;

               }


               // Particles

               for(let i=this.particles.length-1; i>=0; i--) {

                   const p = this.particles[i]; p.position.add(p.vel); p.life-=0.05;

                   p.material.opacity=p.life; p.scale.setScalar(p.life);

                   if(p.life<=0){ this.scene.remove(p); this.particles.splice(i,1); }

               }


               this.ren.render(this.scene, this.cam);

           }

       };


       // --- 5. REALISTIC MODELS ---

       const Models = {

           train(type) {

               const g = new THREE.Group();

               const bend = {onBeforeCompile: Curver.inject};

               const tex = type==='red' ? Assets.red : Assets.metal;

               const mat = new THREE.MeshStandardMaterial({map:tex, metalness:0.3, roughness:0.4, ...bend});

              

               // Body

               const b = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3.8, 16), mat);

               b.position.y = 2.4; b.castShadow = true; g.add(b);

              

               // Roof

               const r = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 16, 16, 1, false, 0, Math.PI), mat);

               r.rotation.set(0, Math.PI/2, Math.PI/2); r.position.y = 4.3; g.add(r);


               // Undercarriage

               const uMat = new THREE.MeshStandardMaterial({color:0x111, ...bend});

               const u = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 14), uMat);

               u.position.y = 0.4; g.add(u);


               // Wheels

               const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 3.4, 12); wGeo.rotateZ(Math.PI/2);

               [4, 5, -4, -5].forEach(z => {

                   const w = new THREE.Mesh(wGeo, uMat); w.position.set(0, 0.5, z); g.add(w);

               });


               return { mesh:g, type:'train', w:3.2, h:5.9, d:16, yTop:4.8 }; // Hitbox info

           }

       };


       // --- 6. PLAYER (High Detail Rig) ---

       const Player = {

           mesh:null, rig:{}, lane:0, x:0, y:0, vy:0, prevY:0, state:'run',

          

           init() {

               const g = new THREE.Group();

               const bend = {onBeforeCompile: Curver.inject};

              

               this.body = new THREE.Group(); this.body.position.y=0.9; g.add(this.body);


               // Materials

               const mSkin = new THREE.MeshStandardMaterial({color:0xffccaa, ...bend});

               const mJean = new THREE.MeshStandardMaterial({color:0x2980b9, roughness:0.8, ...bend});

               const mHood = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.7, ...bend}); // White hoodie

               const mShoe = new THREE.MeshStandardMaterial({color:0xe74c3c, ...bend});


               // Helper for joints

               const limb = (w, h, m, x, y) => {

                   const l = new THREE.Group(); l.position.set(x,y,0);

                   const mesh = new THREE.Mesh(new THREE.CylinderGeometry(w, w*0.8, h, 8), m);

                   mesh.castShadow=true; mesh.position.y = -h/2;

                   const joint = new THREE.Mesh(new THREE.SphereGeometry(w, 8, 8), m);

                   l.add(joint); l.add(mesh);

                   return l;

               };


               // Torso

               const torso = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.55, 0.25), mHood);

               torso.castShadow=true; torso.position.y=0.3; this.body.add(torso);


               // Head

               const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), mSkin);

               head.position.y = 0.7; this.body.add(head);

              

               // Cap

               const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.21, 0.21, 0.15, 16), mJean);

               cap.position.y = 0.1; head.add(cap);

               const brim = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.05, 0.2), mJean);

               brim.position.set(0, 0.05, 0.2); head.add(brim);


               // Limbs

               this.rig = {

                   lL: limb(0.09, 0.5, mJean, -0.12, 0),

                   lR: limb(0.09, 0.5, mJean, 0.12, 0),

                   aL: limb(0.08, 0.45, mHood, -0.3, 0.5),

                   aR: limb(0.08, 0.45, mHood, 0.3, 0.5)

               };

               for(let k in this.rig) this.body.add(this.rig[k]);


               Game.scene.add(g);

               this.mesh = g;

           },


           reset() {

               this.lane=0; this.x=0; this.y=0; this.vy=0;

               this.mesh.position.set(0,0,0); this.body.rotation.set(0,0,0);

           },


           move(d) { this.lane = Math.max(-1, Math.min(1, this.lane+d)); },

           jump() { if(this.y < 0.1) { this.vy = CFG.JUMP; this.state='jump'; } },

           roll() { if(this.y > 0.5) this.vy = -1.2; this.state='roll'; },


           update() {

               this.prevY = this.y;

               const tx = CFG.LANES[this.lane+1];

               this.x += (tx - this.x) * 0.2;

               this.mesh.position.x = this.x;

               this.mesh.rotation.z = -(tx - this.x) * 0.1;


               this.y += this.vy;

               this.vy -= CFG.GRAVITY;


               // Ground Collision

               const gh = Level.getHeight(this.x, -Game.world.position.z);

               if(this.y <= gh) {

                   this.y = gh; this.vy = 0;

                   if(this.state === 'jump') this.state = 'run';

               }

               this.mesh.position.y = this.y;


               // Animation Cycle

               if(this.state === 'roll') {

                   this.body.rotation.x -= 0.6;

                   this.body.position.y = 0.5;

                   if(Math.abs(this.body.rotation.x) > Math.PI*2) {

                       this.state='run'; this.body.rotation.x=0; this.body.position.y=0.9;

                   }

               } else if(this.state === 'jump') {

                   this.rig.lL.rotation.x = 0.5; this.rig.lR.rotation.x = -0.2;

                   this.rig.aL.rotation.x = -2.5; this.rig.aR.rotation.x = -2.5;

               } else {

                   const t = Date.now() * 0.02;

                   this.rig.lL.rotation.x = Math.sin(t);

                   this.rig.lR.rotation.x = Math.sin(t + Math.PI);

                   this.rig.aL.rotation.x = Math.sin(t + Math.PI);

                   this.rig.aR.rotation.x = Math.sin(t);

                   this.body.position.y = 0.9 + Math.sin(t*2)*0.05;

               }


               if(Level.checkCrash(this.x, this.y, this.prevY, -Game.world.position.z)) {

                   Game.gameOver();

               }

           }

       };


       // --- 7. LEVEL ---

       const Level = {

           chunks:[], obs:[], coins:[], spawnZ:0,

           init() { this.reset(); },

           reset() {

               this.chunks.forEach(c => Game.world.remove(c));

               this.chunks = []; this.obs = []; this.coins = [];

               this.spawnZ = 0;

               for(let i=0; i<5; i++) this.spawnChunk(i > 1); // First 2 safe

           },

          

           update(wz) {

               while(this.spawnZ < wz + 200) {

                   this.spawnChunk(true, -this.spawnZ);

                   this.spawnZ += 30;

               }

               this.obs.forEach(o => {

                   if(o.moving) { o.mesh.position.z += 0.35; o.z += 0.35; }

               });

               this.obs = this.obs.filter(o => o.z + wz < 30);

               this.coins.forEach(c => {

                   if(c.col) return;

                   c.mesh.rotation.y += 0.1;

                   if(Math.abs(c.x - Player.x) < 1 && Math.abs(c.y - Player.y) < 1.5 && Math.abs(c.z - (-wz)) < 1.5) {

                       c.mesh.visible = false; c.col = true; Game.coins++;

                       Game.spawnP(Player.x, Player.y+1, -wz+1);

                   }

               });

           },


           spawnChunk(hasObs, z) {

               const g = new THREE.Group(); g.position.z = z;

               Game.world.add(g); this.chunks.push(g);

               const bend = {onBeforeCompile: Curver.inject};


               // Floor

               const gr = new THREE.Mesh(new THREE.PlaneGeometry(30,30), new THREE.MeshStandardMaterial({map:Assets.ground, ...bend}));

               gr.rotation.x = -Math.PI/2; gr.position.z = -15; gr.receiveShadow = true; g.add(gr);


               // Walls

               const wMat = new THREE.MeshStandardMaterial({map:Assets.brick, ...bend});

               const w1 = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 30), wMat); w1.position.set(-10,4,-15); g.add(w1);

               const w2 = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 30), wMat); w2.position.set(10,4,-15); g.add(w2);


               if(hasObs) {

                   const l = [...CFG.LANES].sort(()=>Math.random()-.5);

                   const type = Math.random();

                  

                   if(type < 0.3) {

                       // Moving Silver Train

                       const t = Models.train('silver');

                       t.mesh.position.set(l[0], 0, -25); g.add(t.mesh);

                       this.obs.push({...t, x:l[0], z:z+ -25, moving:true});

                       this.spawnCoins(g, l[1], 1, -15, z);

                   } else if(type < 0.6) {

                       // Static Red Train

                       const t = Models.train('red');

                       t.mesh.position.set(l[0], 0, -15); g.add(t.mesh);

                       this.obs.push({...t, x:l[0], z:z+ -15});

                       this.spawnCoins(g, l[0], 5.8, -15, z);

                   } else {

                       // Barriers

                       const bMat = new THREE.MeshStandardMaterial({color:0xe74c3c, map:Assets.metal, ...bend});

                       const b = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 0.2), bMat);

                       b.position.set(l[0], 0.6, -15); g.add(b);

                       this.obs.push({type:'barrier', x:l[0], z:z+ -15, w:3, d:0.5});

                       this.spawnCoins(g, l[0], 2, -15, z);

                   }

               }

               this.spawnZ += 30;

           },


           spawnCoins(g, x, y, lz, wz) {

               const bend = {onBeforeCompile: Curver.inject};

               const mat = new THREE.MeshStandardMaterial({map:Assets.coin, transparent:true, side:THREE.DoubleSide, ...bend});

               for(let i=0; i<5; i++) {

                   const c = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.1,16), mat);

                   c.rotation.z = Math.PI/2; c.position.set(x, y, lz - i*2); g.add(c);

                   this.coins.push({mesh:c, x:x, y:y, z:wz+lz-i*2, col:false});

               }

           },


           getHeight(x, z) {

               // Height logic: Only return height if we are INSIDE the X/Z bounds

               for(let o of this.obs) {

                   if(o.type === 'train') {

                       if(Math.abs(x - o.x) < 1.2 && Math.abs(z - o.z) < o.d/2 + 1) {

                           return o.yTop;

                       }

                   }

               }

               return 0;

           },


           checkCrash(x, y, py, z) {

               for(let o of this.obs) {

                   // Collision bounds

                   if(Math.abs(x - o.x) < 1.0) {

                       const dz = Math.abs(z - o.z);

                      

                       if(o.type === 'train' && dz < o.d/2 + 0.5) {

                           // Fatal: If we were BELOW the top previously, we hit the face.

                           // Small buffer (0.2) to prevent clipping edges

                           if(py < o.yTop - 0.2) return true;

                       }

                       if(o.type === 'barrier' && dz < 0.5) {

                           if(y < 1.0) return true;

                       }

                   }

               }

               return false;

           }

       };


       window.onload = () => Game.init();

   </script>

</body>

</html>

